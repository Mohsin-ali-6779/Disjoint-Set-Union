#include <bits/stdc++.h>
using namespace std;

class DisjointSet {
public:
    vector<int> parent, size;

    DisjointSet(int n) {
        parent.resize(n + 1);
        size.resize(n + 1);
        for (int i = 0; i <= n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    int FindUPar(int node) {
        if (parent[node] == node)
            return node;
        return parent[node] = FindUPar(parent[node]); // Path compression
    }

    void UnionBySize(int u, int v) {
        int ulp_u = FindUPar(u), ulp_v = FindUPar(v);
        if (ulp_u == ulp_v)
            return;

        if (size[ulp_u] < size[ulp_v]) {
            parent[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        } else {
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }
};

int main() {
    int node, edg;
    cin >> node >> edg;

    vector<tuple<int, int, int>> edges;

    for (int i = 0; i < edg; i++) {
        int u, v, wt;
        cin >> u >> v >> wt;
        edges.push_back({wt, u, v});
    }

    // Sort edges by weight
    sort(edges.begin(), edges.end());

    DisjointSet dsu(node);
    int min_wt_spanning = 0;

    for (auto& [wt, u, v] : edges) {
        if (dsu.FindUPar(u) != dsu.FindUPar(v)) {
            min_wt_spanning += wt;
            dsu.UnionBySize(u, v);
        }
    }

    cout << min_wt_spanning << endl;
    return 0;
}
